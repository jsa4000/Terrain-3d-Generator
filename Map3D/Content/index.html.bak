<!DOCTYPE html>
<html>
<head>

    <title>WebGL 3D Model Viewer Using three.js</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script src="three.js"></script>
    <script src="Detector.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="OBJLoader.js"></script>
    <script src="MTLLoader.js"></script>

    <style>
		body {
			background-color: #333333;
            margin: 0px;
            overflow: hidden;
            background-image: -webkit-gradient(#000000,#111111,#000000);
            /* Safari 5.1, iOS 5.0-6.1, Chrome 10-25, Android 4.0-4.3 */
            background-image: -webkit-linear-gradient(#000000,#111111,#000000);
            /* Firefox 3.6 - 15 */
            background-image: -moz-linear-gradient(#000000,#333333,#000000);
            /* Opera 11.1 - 12 */
            background-image: -o-linear-gradient(#000000,#333333,#000000);
            /* Opera 15+, Chrome 25+, IE 10+, Firefox 16+, Safari 6.1+, iOS 7+, Android 4.4+ */
            background-image: linear-gradient(#000000,#333333,#000000);
		}
        p {
            margin: 0;
            padding: 0;
        }

        .left,
        .right {
            position: absolute;
            color: #fff;
            font-family: Geneva, sans-serif;
        }

        .left {
            top: 0;
            left: 1em;
            text-align: left;
        }
		
		.leftM {
			position: absolute;
            color: #fff;
            top: 50%;
            left: 1em;
            text-align: left;
        }
		.right {
            top: 0;
            right: 0;
            text-align: right;
        }
		 .top {
            top: 0;
			width:100%;
            text-align: center;
        }
		 .bottom {
            bottom: 1em;
            right: 1em;
            text-align: left;
        }
		.midR {
            bottom: 50%;
            right: 1em;
            text-align: left;
        }
		 .bottomL {
            bottom: 7em;
            left: 1em;
            text-align: left;
        }
		.textInfo {
			position: relative;
			color:#fff;
			z-index:100;
			font-size: 14px;
			font-weight: bold;
			text-align: center;
		}
		.title {
			position: relative;
			color:#fff;
			z-index:100;
			font-size: 30px;
			font-weight: bold;
			text-align: center;
		}
	a { color:skyblue }
    </style>

</head>
<body>

	<div class="left">
        <img src="essp-logo-mobile.png" style="width:200px">
    </div>
	
	<div class="top" style = "position: absolute" >
		<div class="title">PRN 136 - 02/11/2016 09:30:00 to 03/11/2016 09:29:59</div>
		<div class="title">Availability & Continuity Map</div>
	</div>

	<div id="box-shadow-div" class="midR" style = "position: absolute" >
		<table style="width:100%">
			<tr>
				<th class="textInfo">Availability</th>
				<th class="textInfo">Continuity</div></th>
				<th class="textInfo">Coordinates (Lat/Long)</th>
			</tr>
			<tr>
				<td><div id="AvInfo" class="textInfo"></div></td>
				<td><div id="ContInfo" class="textInfo" ></div></td>
				<td><div id="CoordInfo" class="textInfo" ></div></td>
			</tr>
		</table> 
	</div>
	
	<div class="bottomL"  border="1" style = "position: absolute; border-style: solid; border-color: #FFFFFF #FFFFFF;" >
   	    <table style="width:100%;border:2px">
			<tr>
				<th class="textInfo">Type</th>
				<th class="textInfo">Commitment Covered </div></th>
			</tr>
			<tr>
				<td class="textInfo">Availability 100%</td>
				<td class="textInfo">72.99%</td>
			</tr>
			<tr>
				<td class="textInfo">Continuity &le;5x10<sup>-4</sup></td>
				<td class="textInfo" >99.10%</td>
			</tr>
		</table> 
	</div>
	
	<div class="leftM" >
		<table style="width:100%;border:2px">
			<tr style = "text-align: left;"><td ><label><input type='checkbox' onclick='handleClick(this);'>Material</label></td></tr>
			<tr style = "text-align: left;"><td ><label><input checked type='checkbox' onclick='handleClick2(this);'>Wireframe</label></td></tr>
			<tr style = "text-align: left;"><td ><label><input type='checkbox' onclick='handleClick3(this);'>Availability Plane</label></td></tr>
			<tr id="avPlaneRow" style = "text-align: left;visibility: collapse;"><td ><input id="rangeCtrl" type="range" value="50" min="0" max="100" step="1" onchange="showVal(this.value)"><label id="lblRange"></label></td></tr>
			
		</table> 
	</div>
	
    <a class="right">
        <img src="legend.png">
    </a>
  
    <script>

        if (!Detector.webgl) {
            Detector.addGetWebGLMessage();
        }

		var meshPlane, showAvPlane;
		var animateStop;
		var geometry, geometry2, dot, showCut;
        var container;
				 
		var raycaster = new THREE.Raycaster();
		var vector = new THREE.Vector3();
		var dir = new THREE.Vector3();
		
		var targetList = [];
		
		var initialOrigin;
        var camera, controls, scene, renderer;
        var lighting, ambient, keyLight, fillLight, backLight, hemiLight;
		
		var currentMaterial, material1, material2, meshAv,   wireframe, switchedmaterial;

		var angle = 0;
		var radius = 5; 
		
        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;
		var AvInfo, ContInfo,CoordInfo, bsDiv;
        
		init();
        animate();

        function init() {
		
			bsDiv = document.getElementById("box-shadow-div");
			AvInfo = document.getElementById('AvInfo');
			ContInfo = document.getElementById('ContInfo');
			CoordInfo = document.getElementById('CoordInfo');
            container = document.createElement('div');
            document.body.appendChild(container);

			//var helper = new THREE.CameraHelper( light.shadow.camera );
			//scene.add( helper );
			wireframe = true;
			switchedmaterial = false;
			showCut = false;
			animateStop = false;
			showAvPlane = false;
			bsDiv.hidden = true;
	
            /* Scene */

            scene = new THREE.Scene();
            lighting = true;

			/* Camera */

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 3.3;
			camera.position.y = 1.5;
			camera.position.x = 1.5;
			
			var origin = new THREE.Vector3();
			origin = scene.position;
			origin.x -= 1.1; 
			origin.z -= 1.1; 
			origin.y -= 0.5;
			initialOrigin = origin;
			camera.lookAt(origin);
			
            ambient = new THREE.AmbientLight(0xffffff, 64.0);
			ambient.castShadow = true;
            scene.add(ambient);

			hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.9 );
			hemiLight.color.setHSL( 1, 1,1 );
			hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			hemiLight.position.set( 0, 500, 0 );
			
            keyLight = new THREE.DirectionalLight(new THREE.Color('hsl(30, 100%, 75%)'), 1.0);
            keyLight.position.set(-100, 0, 200);
			keyLight.castShadow = true;
			
            fillLight = new THREE.DirectionalLight(new THREE.Color('hsl(240, 100%, 75%)'), 0.75);
            fillLight.position.set(100, 0, 200);
			fillLight.castShadow = true;

            backLight = new THREE.DirectionalLight(0xffffff, 1.0);
            backLight.position.set(100, 0, -100).normalize();
			backLight.castShadow = true;
			
			if (lighting) {
				 ambient.intensity = 0.25;
				 scene.add(hemiLight );
				 scene.add(keyLight);
				 scene.add(fillLight);
				 scene.add(backLight);
			}
			
            /* Model */
            var mtlLoader = new THREE.MTLLoader();
            mtlLoader.setBaseUrl('assets/');
            mtlLoader.setPath('assets/');

            mtlLoader.load('av.mtl', function (materials) {
                materials.preload();

                materials.materials.texture.map.magFilter = THREE.NearestFilter;
                materials.materials.texture.map.minFilter = THREE.LinearFilter;
				
				material1 = materials.materials.texture;
				material2 = materials.materials.texture2;
			
				material1.needsUpdate = true;
				material2.needsUpdate = true;
				
				currentMaterial = material1;
				currentMaterial.wireframe = wireframe;
						
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('assets/');
                objLoader.load('av.obj', function (object) {
					object.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh ) {
							meshAv = child;
							geometry = new THREE.Geometry().fromBufferGeometry(meshAv.geometry);
							meshAv.dynamic = true;
						
						}

					} );
	                scene.add(object);
					targetList.push(object);
	            });

            });
			
			mtlLoader.load('cont.mtl', function (materials) {
                materials.preload();
                materials.materials.texture.map.magFilter = THREE.NearestFilter;
                materials.materials.texture.map.minFilter = THREE.LinearFilter;
						
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('assets/');
                objLoader.load('cont.obj', function (object) {
				object.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh ) {
							//meshCont = child;
							geometry2 = new THREE.Geometry().fromBufferGeometry(child.geometry);
						}

					} );
                    scene.add(object);
                });

            });
			/*
			mtlLoader.load('av_99_plane_APV1.mtl', function (materials) {
                materials.preload();
                materials.materials.texture.map.magFilter = THREE.NearestFilter;
                materials.materials.texture.map.minFilter = THREE.LinearFilter;
						
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('assets/');
                objLoader.load('av_99_plane_APV1.obj', function (object) {
                    //scene.add(object);
					//object.position.y -= 0.2;
					object.position.y -= 1;
					object.position.y += 0.5;
					meshPlane = object;
                });

            });
*/
            /* Renderer */

            renderer = new THREE.WebGLRenderer( { alpha: true, antialias: false } );
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            //renderer.setClearColor(new THREE.Color("hsl(0, 0%, 10%)"));

            container.appendChild(renderer.domElement);

            /* Controls */

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.enableZoom = false;
			controls.enablePan = false;
			
			// How far you can orbit vertically, upper and lower limits.
			controls.maxPolarAngle = Math.PI/2; 
		
            /* Events */

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', onKeyboardEvent, false);
			
			// when the mouse moves, call the given function
			window.addEventListener( 'mousemove', onMouseMove, false );
			window.addEventListener( 'mousedown', onMousedown, false );

        }
		 
		 function onMousedown( event ) {
			animateStop = true;
		 }
		 
		
		 function onMouseMove( event ) {
			event.preventDefault();
				if ( camera instanceof THREE.OrthographicCamera ) {
				vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, - 1 ); // z = - 1 important!
				vector.unproject( camera );
				dir.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
				raycaster.set( vector, dir );
			} else if ( camera instanceof THREE.PerspectiveCamera ) {
				vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 ); // z = 0.5 important!
				vector.unproject( camera );
				raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
			}

			var intersects = raycaster.intersectObjects( targetList, true );
	
		   if (intersects.length > 0) {
				var index = intersects[0].faceIndex;
				var face = intersects[0].face;
				
				var vertices = geometry.vertices;
				var v1 = vertices[ face.a ];
				var v2 = vertices[ face.b ];
				var v3 = vertices[ face.c ];

				// calculate the centroid
				var position = new THREE.Vector3();
				position.x = ( v1.x + v2.x + v3.x ) / 3;
				position.y = ( v1.y + v2.y + v3.y ) / 3;
				position.z = ( v1.z + v2.z + v3.z ) / 3;
						
				// http://stackoverflow.com/questions/26887664/three-js-raycasting-intercepting-particles-with-attenuated-sizes
				scene.remove(dot);
				var dotGeometry = new THREE.Geometry();
				dotGeometry.vertices.push(position);
				//var sprite = THREE.ImageUtils.loadTexture("gaus16.png"); 'Deprecated
				//Use Instead following
				var texloader = new THREE.TextureLoader();
				var tex=texloader.load("gaus162.png");
				
				var pSize = 9;
				if (showCut){
					pSize = 16;
				}
				
				var dotMaterial = new THREE.PointsMaterial( { color: 0xFF0000, size: pSize, sizeAttenuation: showCut} );
				if (showCut){
					//dotMaterial.map = tex;
					dotMaterial.opacity = 0.5;
					dotMaterial.transparent = true;
				}
			
				dot = new THREE.Points( dotGeometry, dotMaterial );
				//dot.rotation.z += 90; 
				scene.add( dot );
				
               //Get the average for the continuity at that face
				var vertexColors2 = geometry2.colors;
				var vc1Cont = vertexColors2[face.a];
				var vc2Cont = vertexColors2[face.b];
				var vc3Cont = vertexColors2[face.c];
						 
				 // calculate the centroid
				var positionCont = new THREE.Vector3();
				positionCont.x = (vc1Cont.r + vc2Cont.r + vc3Cont.r) / 3;
				positionCont.y = (vc1Cont.g + vc2Cont.g + vc3Cont.g) / 3;
				positionCont.z = (vc1Cont.b + vc2Cont.b + vc3Cont.b) / 3;
				
		       //Get the Availability a that point
				var vertexColors = geometry.colors;
				var vc1 = vertexColors[ face.a ];
				var vc2 = vertexColors[ face.b ];
				var vc3 = vertexColors[ face.c ];
							 
				 // calculate the centroid
				var positionAv = new THREE.Vector3();
				positionAv.x = (vc1.r + vc2.r + vc3.r) / 3;
				positionAv.y = (vc1.g + vc2.g + vc3.g) / 3;
				positionAv.z = (vc1.b + vc2.b + vc3.b) / 3;
				
				//color.style.background = 0xdddddd;
				AvInfo.textContent = (positionAv.z * 100).toFixed(2) + "%";
				ContInfo.textContent = positionCont.z.toExponential(3);
				//CoordInfo.textContent =  (positionc.x.toFixed(2)* 30).toFixed(2) + " / " + (positionc.y.toFixed(2) * 10).toFixed(2);
				CoordInfo.textContent = positionAv.x.toFixed(2) + " / " + positionAv.y.toFixed(2);
				
				bsDiv.hidden = false;
				
			}
			else {
				scene.remove(dot);
				bsDiv.hidden = true;
			}
		}
		
        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyboardEvent(e) {
			switch(e.code) {
				case 'KeyL':
					lighting = !lighting;
					if (lighting) {
						ambient.intensity = 0.25;
						scene.add(keyLight);
						scene.add(fillLight);
						scene.add(backLight);
						scene.add( hemiLight );
					} else {
						ambient.intensity = 1.0;
						scene.remove(keyLight);
						scene.remove(fillLight);
						scene.remove(backLight);
						scene.remove( hemiLight );
					}
					break;
				case 'KeyW':
					wireframe = !wireframe;
					currentMaterial.wireframe = wireframe;
					break;
				case 'KeyM':
					switchedmaterial = !switchedmaterial;
					
					if (switchedmaterial){
						currentMaterial = material2;
					}
					else {
						currentMaterial = material1;
					}
					meshAv.material = currentMaterial;
					currentMaterial.wireframe = wireframe;
					break;
				case 'KeyP':
					showCut = !showCut;
					break;
				default:
			} 
        }

		function handleClick2(cb) {
			wireframe = cb.checked;
			currentMaterial.wireframe = wireframe;
		
		
			camera.position.z = 3.3;
			camera.position.y = 1.5;
			camera.position.x = 1.5;
			camera.lookAt(initialOrigin);
			angle = 0;
			animateStop = false;
		}
		
		 function showVal(newVal){
			document.getElementById("lblRange").innerHTML= newVal  + "%";
			console.log(meshPlane.position.y);
			meshPlane.position.y = -1 + (newVal / 100);
			console.log(meshPlane.position.y);
		}
		 
		
		function handleClick3(cb) {
			showAvPlane = cb.checked;
			if (showAvPlane) {
				scene.add(meshPlane);
				document.getElementById("avPlaneRow").style.visibility = "visible";
			} else {
				scene.remove(meshPlane);
				document.getElementById("avPlaneRow").style.visibility = "hidden";
			}
		
		
			camera.position.z = 3.3;
			camera.position.y = 1.5;
			camera.position.x = 1.5;
			camera.lookAt(initialOrigin);
			angle = 0;
			animateStop = false;
		}
		
		function handleClick(cb) {
			switchedmaterial = cb.checked;
					
			if (switchedmaterial){
				currentMaterial = material2;
			}
			else {
				currentMaterial = material1;
			}
			meshAv.material = currentMaterial;
			currentMaterial.wireframe = wireframe;
		
			camera.position.z = 3.3;
			camera.position.y = 1.5;
			camera.position.x = 1.5;
			camera.lookAt(initialOrigin);
			angle = 0;
			animateStop = false;
		}
		
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
	
			if (!animateStop) {
				//meshAv.rotation.y -= 0.005;
				//meshCont.rotation.y -= 0.005;
				camera.position.x = radius * Math.cos( angle );  
				camera.position.z = radius * Math.sin( angle );
				angle += 0.005;
			}
	
	
            render();
        }

        function render() {
	
            renderer.render(scene, camera);

        }

    </script>

</body>
</html>
