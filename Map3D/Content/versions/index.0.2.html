<!DOCTYPE html>
<html>
<head>

    <title>WebGL 3D Model Viewer Using three.js</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script src="three.js"></script>
    <script src="Detector.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="OBJLoader.js"></script>
    <script src="MTLLoader.js"></script>
	<script src="dat.gui.js"></script>

    <style>
		body {
			background-color: #333333;
            margin: 0px;
            overflow: hidden;
            background-image: -webkit-gradient(#000000,#111111,#000000);
            /* Safari 5.1, iOS 5.0-6.1, Chrome 10-25, Android 4.0-4.3 */
            background-image: -webkit-linear-gradient(#000000,#111111,#000000);
            /* Firefox 3.6 - 15 */
            background-image: -moz-linear-gradient(#000000,#333333,#000000);
            /* Opera 11.1 - 12 */
            background-image: -o-linear-gradient(#000000,#333333,#000000);
            /* Opera 15+, Chrome 25+, IE 10+, Firefox 16+, Safari 6.1+, iOS 7+, Android 4.4+ */
            background-image: linear-gradient(#000000,#333333,#000000);
		}
        p {
            margin: 0;
            padding: 0;
        }

        .left,
        .right {
            position: absolute;
            color: #fff;
            font-family: Geneva, sans-serif;
        }

        .left {
            top: 0;
            left: 1em;
            text-align: left;
        }
		
		.leftM {
			position: absolute;
            color: #fff;
            top: 50%;
            left: 1em;
            text-align: left;
        }
		.right {
            top: 0;
            right: 0;
            text-align: right;
        }
		 .top {
            top: 0;
			width:100%;
            text-align: center;
        }
		 .bottom {
            bottom: 1em;
            right: 1em;
            text-align: left;
        }
		.midR {
            bottom: 50%;
            right: 1em;
            text-align: left;
        }
		 .bottomL {
            bottom: 7em;
            left: 1em;
            text-align: left;
        }
		.textInfo {
			position: relative;
			color:#fff;
			z-index:100;
			font-size: 14px;
			font-weight: bold;
			text-align: center;
		}
		.title {
			position: relative;
			color:#fff;
			z-index:100;
			font-size: 30px;
			font-weight: bold;
			text-align: center;
		}
		.dg.a { 
			position: absolute !important; 
			top: 13.1em !important; 
			left: 1em !important; 
			margin-right:170px !important; 
		}
		 .dg .close-button { display:none;}  		
			
		a { color:skyblue }
    </style>

</head>
<body>

	<div class="left">
        <img src="essp-logo-mobile.png" style="width:200px">
    </div>
	
	<div class="top" style = "position: absolute" >
		<div class="title">PRN 136 - 02/11/2016 09:30:00 to 03/11/2016 09:29:59</div>
		<div class="title">Availability & Continuity Map</div>
	</div>

	<div id="box-shadow-div" class="midR" style = "position: absolute" >
		<table style="width:100%">
			<tr>
				<th class="textInfo">Availability</th>
				<th class="textInfo">Continuity</div></th>
				<th class="textInfo">Coordinates (Lat/Long)</th>
			</tr>
			<tr>
				<td><div id="AvInfo" class="textInfo"></div></td>
				<td><div id="ContInfo" class="textInfo" ></div></td>
				<td><div id="CoordInfo" class="textInfo" ></div></td>
			</tr>
		</table> 
	</div>
	
	<div class="bottomL"  border="1" style = "position: absolute; border-style: solid; border-color: #FFFFFF #FFFFFF;" >
   	    <table style="width:100%;border:2px">
			<tr>
				<th class="textInfo">Type</th>
				<th class="textInfo">Commitment Covered </div></th>
			</tr>
			<tr>
				<td class="textInfo">Availability 100%</td>
				<td class="textInfo">72.99%</td>
			</tr>
			<tr>
				<td class="textInfo">Continuity &le;5x10<sup>-4</sup></td>
				<td class="textInfo" >99.10%</td>
			</tr>
		</table> 
	</div>
	
    <a class="right">
        <img src="legend.png">
    </a>
  
    <script>

        if (!Detector.webgl) {
            Detector.addGetWebGLMessage();
        }

		var gui, parameters;
		
		var meshPlane, showAvPlane, slrPlane;
		var animateStop;
		var geometry, geometry2, dot, showCut;
        var container;
				 
		var raycaster = new THREE.Raycaster();
		var vector = new THREE.Vector3();
		var dir = new THREE.Vector3();
		
		var targetList = [];
		
		var initialOrigin;
        var camera, controls, scene, renderer;
        var lighting, ambient, keyLight, fillLight, backLight, hemiLight;
		
		var currentMaterial, material1, material2, meshAv,   wireframe, switchedmaterial;

		var angle = 0;
		var radius = 5; 
		
        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;
		var AvInfo, ContInfo,CoordInfo, bsDiv;
        
		init();
		initGUI();
        animate();

		function initGUI(){
			gui = new dat.GUI();
				
			parameters = 
			{
				material: false,
				wireframe: true,
				avPlane: false,
				sliderAv: 50
			};
			
			var chkMaterial = gui.add( parameters, 'material' ).name('Material').listen();
			chkMaterial.onChange(function(value) 
			{   
				handleClick(value);
			});
			
			var chkWireframe = gui.add( parameters, 'wireframe' ).name('Wireframe').listen();
			chkWireframe.onChange(function(value) 
			{   
				handleClick2(value);
			});
			var chkAvPlane = gui.add( parameters, 'avPlane' ).name('Availability Plane').listen();
			chkAvPlane.onChange(function(value) 
			{   
				handleClick3(value);
			});
		
			slrPlane = gui.add( parameters, 'sliderAv' ).min(0).max(100).step(0.1).name('Coverage').listen();
			slrPlane.onChange(function(value)
			{   
				showVal(value);
			});
			//gui.remove(item);
			slrPlane.domElement.style.pointerEvents = "none"
			slrPlane.domElement.style.opacity = .5;
		
			//dat.GUI.toggleHide();
			gui.open();
		}
		
        function init() {
		
			bsDiv = document.getElementById("box-shadow-div");
			AvInfo = document.getElementById('AvInfo');
			ContInfo = document.getElementById('ContInfo');
			CoordInfo = document.getElementById('CoordInfo');
            container = document.createElement('div');
            document.body.appendChild(container);

			//var helper = new THREE.CameraHelper( light.shadow.camera );
			//scene.add( helper );
			showCut = false;
			animateStop = false;
	
            /* Scene */

            scene = new THREE.Scene();
            lighting = true;

			/* Camera */

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 3.3;
			camera.position.y = 1.5;
			camera.position.x = 1.5;
			
			var origin = new THREE.Vector3();
			origin = scene.position;
			origin.x -= 1.1; 
			origin.z -= 1.1; 
			origin.y -= 0.5;
			initialOrigin = origin;
			camera.lookAt(origin);
			
            ambient = new THREE.AmbientLight(0xffffff, 64.0);
			ambient.castShadow = true;
            scene.add(ambient);

			hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.9 );
			hemiLight.color.setHSL( 1, 1,1 );
			hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			hemiLight.position.set( 0, 500, 0 );
			
            keyLight = new THREE.DirectionalLight(new THREE.Color('hsl(30, 100%, 75%)'), 1.0);
            keyLight.position.set(-100, 0, 200);
			keyLight.castShadow = true;
			
            fillLight = new THREE.DirectionalLight(new THREE.Color('hsl(240, 100%, 75%)'), 0.75);
            fillLight.position.set(100, 0, 200);
			fillLight.castShadow = true;

            backLight = new THREE.DirectionalLight(0xffffff, 1.0);
            backLight.position.set(100, 0, -100).normalize();
			backLight.castShadow = true;
			
			if (lighting) {
				 ambient.intensity = 0.25;
				 scene.add(hemiLight );
				 scene.add(keyLight);
				 scene.add(fillLight);
				 scene.add(backLight);
			}
			
            /* Model */
            var mtlLoader = new THREE.MTLLoader();
            mtlLoader.setBaseUrl('assets/');
            mtlLoader.setPath('assets/');

            mtlLoader.load('av.mtl', function (materials) {
                materials.preload();

                materials.materials.texture.map.magFilter = THREE.NearestFilter;
                materials.materials.texture.map.minFilter = THREE.LinearFilter;
				
				material1 = materials.materials.texture;
				material2 = materials.materials.texture2;
			
				material1.needsUpdate = true;
				material2.needsUpdate = true;
				
				currentMaterial = material1;
				currentMaterial.wireframe = wireframe;
						
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('assets/');
                objLoader.load('av.obj', function (object) {
					object.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh ) {
							meshAv = child;
							geometry = new THREE.Geometry().fromBufferGeometry(meshAv.geometry);
							meshAv.dynamic = true;
							handleClick2(true)
						}

					} );
	                scene.add(object);
					targetList.push(object);
	            });

            });
			
			mtlLoader.load('cont.mtl', function (materials) {
                materials.preload();
                materials.materials.texture.map.magFilter = THREE.NearestFilter;
                materials.materials.texture.map.minFilter = THREE.LinearFilter;
						
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('assets/');
                objLoader.load('cont.obj', function (object) {
				object.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh ) {
							//meshCont = child;
							geometry2 = new THREE.Geometry().fromBufferGeometry(child.geometry);
						}

					} );
                    scene.add(object);
                });

            });
			
			mtlLoader.load('av_99_plane_APV1.mtl', function (materials) {
                materials.preload();
                materials.materials.texture.map.magFilter = THREE.NearestFilter;
                materials.materials.texture.map.minFilter = THREE.LinearFilter;
						
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('assets/');
                objLoader.load('av_99_plane_APV1.obj', function (object) {
					object.position.y += 0.5;
					meshPlane = object;
                });

            });
	
			//scene.fog = new THREE.FogExp2( 0x000022, 0.05025 );

            /* Renderer */

            renderer = new THREE.WebGLRenderer( { alpha: true, antialias: false } );
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            //renderer.setClearColor(new THREE.Color("hsl(0, 0%, 10%)"));

            container.appendChild(renderer.domElement);

            /* Controls */

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.enableZoom = false;
			controls.enablePan = false;
			
			// How far you can orbit vertically, upper and lower limits.
			controls.maxPolarAngle = Math.PI/2; 
		
            /* Events */

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', onKeyboardEvent, false);
			
			// when the mouse moves, call the given function
			window.addEventListener( 'mousemove', onMouseMove, false );
			window.addEventListener( 'mousedown', onMousedown, false );

        }
		 
		 function onMousedown( event ) {
			animateStop = true;
		 }
		
		 function onMouseMove( event ) {
			event.preventDefault();
				if ( camera instanceof THREE.OrthographicCamera ) {
				vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, - 1 ); // z = - 1 important!
				vector.unproject( camera );
				dir.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
				raycaster.set( vector, dir );
			} else if ( camera instanceof THREE.PerspectiveCamera ) {
				vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 ); // z = 0.5 important!
				vector.unproject( camera );
				raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
			}

			var intersects = raycaster.intersectObjects( targetList, true );
	
		   if (intersects.length > 0) {
				var index = intersects[0].faceIndex;
				var face = intersects[0].face;
				
				var vertices = geometry.vertices;
				var v1 = vertices[ face.a ];
				var v2 = vertices[ face.b ];
				var v3 = vertices[ face.c ];

				// calculate the centroid
				var position = new THREE.Vector3();
				position.x = ( v1.x + v2.x + v3.x ) / 3;
				position.y = ( v1.y + v2.y + v3.y ) / 3;
				position.z = ( v1.z + v2.z + v3.z ) / 3;
						
				// http://stackoverflow.com/questions/26887664/three-js-raycasting-intercepting-particles-with-attenuated-sizes
				scene.remove(dot);
				var dotGeometry = new THREE.Geometry();
				dotGeometry.vertices.push(position);
				//var sprite = THREE.ImageUtils.loadTexture("gaus16.png"); 'Deprecated
				//Use Instead following
				var texloader = new THREE.TextureLoader();
				var tex=texloader.load("gaus162.png");
				
				var pSize = 9;
				if (showCut){
					pSize = 16;
				}
				
				var dotMaterial = new THREE.PointsMaterial( { color: 0xFF0000, size: pSize, sizeAttenuation: showCut} );
				if (showCut){
					//dotMaterial.map = tex;
					dotMaterial.opacity = 0.5;
					dotMaterial.transparent = true;
				}
			
				dot = new THREE.Points( dotGeometry, dotMaterial );
				//dot.rotation.z += 90; 
				scene.add( dot );
				
               //Get the average for the continuity at that face
				var vertexColors2 = geometry2.colors;
				var vc1Cont = vertexColors2[face.a];
				var vc2Cont = vertexColors2[face.b];
				var vc3Cont = vertexColors2[face.c];
						 
				 // calculate the centroid
				var positionCont = new THREE.Vector3();
				positionCont.x = (vc1Cont.r + vc2Cont.r + vc3Cont.r) / 3;
				positionCont.y = (vc1Cont.g + vc2Cont.g + vc3Cont.g) / 3;
				positionCont.z = (vc1Cont.b + vc2Cont.b + vc3Cont.b) / 3;
				
		       //Get the Availability a that point
				var vertexColors = geometry.colors;
				var vc1 = vertexColors[ face.a ];
				var vc2 = vertexColors[ face.b ];
				var vc3 = vertexColors[ face.c ];
							 
				 // calculate the centroid
				var positionAv = new THREE.Vector3();
				positionAv.x = (vc1.r + vc2.r + vc3.r) / 3;
				positionAv.y = (vc1.g + vc2.g + vc3.g) / 3;
				positionAv.z = (vc1.b + vc2.b + vc3.b) / 3;
				
				//color.style.background = 0xdddddd;
				AvInfo.textContent = positionAv.z.toFixed(2) + "%";
				ContInfo.textContent = positionCont.z.toExponential(3);
				CoordInfo.textContent = positionAv.x.toFixed(2) + " / " + positionAv.y.toFixed(2);
				
				bsDiv.hidden = false;
				
			}
			else {
				scene.remove(dot);
				bsDiv.hidden = true;
			}
		}
		
        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyboardEvent(e) {
			switch(e.code) {
				case 'KeyL':
					lighting = !lighting;
					if (lighting) {
						ambient.intensity = 0.25;
						scene.add(keyLight);
						scene.add(fillLight);
						scene.add(backLight);
						scene.add( hemiLight );
					} else {
						ambient.intensity = 1.0;
						scene.remove(keyLight);
						scene.remove(fillLight);
						scene.remove(backLight);
						scene.remove( hemiLight );
					}
					break;
				case 'KeyW':
					wireframe = !wireframe;
					currentMaterial.wireframe = wireframe;
					break;
				case 'KeyM':
					switchedmaterial = !switchedmaterial;
					
					if (switchedmaterial){
						currentMaterial = material2;
					}
					else {
						currentMaterial = material1;
					}
					meshAv.material = currentMaterial;
					currentMaterial.wireframe = wireframe;
					break;
				case 'KeyP':
					showCut = !showCut;
					break;
				default:
			} 
        }
				
		function handleClick2(checked) {
			parameters.wireframe = checked;
			currentMaterial.wireframe = parameters.wireframe;
		
			camera.position.z = 3.3;
			camera.position.y = 1.5;
			camera.position.x = 1.5;
			camera.lookAt(initialOrigin);
			angle = 0;
			animateStop = false;
		}
		
		 function showVal(newVal){
			var palette = [0,70, 80, 90, 95, 98, 99, 99.9,100];
			var levels = [0,30,	40,	50,	60 ,70, 80,	90,	100];
			
			newVal = newVal
			var value = 0;
			//Get the current value from the new Value
			for (i = 0; i < palette.length - 1; i++) {
				if (newVal >= palette[i] && newVal <= palette[i+1] ) {
					//This means the value is inside these two values
					var percent =  (newVal - palette[i]) / (palette[i+1] - palette[i]);
					value = ((levels[i+1] - levels[i]) * percent) + levels[i];
					break;
				}
			}
			//console.log(value);
			//New Value
			meshPlane.position.y = (value / 100);
		}
		 
		
		function handleClick3(checked) {
			parameters.avPlane = checked;
			if (parameters.avPlane) {
				scene.add(meshPlane);
				slrPlane.domElement.style.pointerEvents = "inherit"
				slrPlane.domElement.style.opacity = 1;
				
			} else {
				scene.remove(meshPlane);
				slrPlane.domElement.style.pointerEvents = "none"
				slrPlane.domElement.style.opacity = .5;
			}
		
			camera.position.z = 3.3;
			camera.position.y = 1.5;
			camera.position.x = 1.5;
			camera.lookAt(initialOrigin);
			angle = 0;
			animateStop = false;
		}
		
		function handleClick(checked) {
			parameters.material = checked;
					
			if (parameters.material){
				currentMaterial = material2;
			}
			else {
				currentMaterial = material1;
			}
			meshAv.material = currentMaterial;
			currentMaterial.wireframe = wireframe;
		
			camera.position.z = 3.3;
			camera.position.y = 1.5;
			camera.position.x = 1.5;
			camera.lookAt(initialOrigin);
			angle = 0;
			animateStop = false;
		}
		
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
	
			if (!animateStop) {
				//meshAv.rotation.y -= 0.005;
				//meshCont.rotation.y -= 0.005;
				camera.position.x = radius * Math.cos( angle );  
				camera.position.z = radius * Math.sin( angle );
				angle += 0.005;
			}
	
	
            render();
        }

        function render() {
	
            renderer.render(scene, camera);

        }

    </script>

</body>
</html>
