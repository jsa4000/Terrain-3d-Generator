<!DOCTYPE html>
<html>
<head>

    <title>Terrain Map 3D</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script src="three.js"></script>
    <script src="Detector.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="OBJLoader.js"></script>
    <script src="MTLLoader.js"></script>
	<script src="dat.gui.min.js"></script>
	<script src="jszip.min.js"></script>
	<script src="xml.js"></script>
	
    <style>
	
		select {
		   background: transparent;
		   border: none;
		   color:#fff;
		}
		table {
			border-radius: 0.6em 0.6em 0.6em 0.6em;		 
			border: 1px solid #444;
			background-color:rgb(30, 30, 30);
		}
		
		th { 
			font-weight: normal;
			padding: 8px;
			text-align: center;
		}
		
		td { 
			padding: 3px;
			text-align: center;
		}
		body {
			background-color: #333333;
            margin: 0px;
            overflow: hidden;
            background-image: -webkit-gradient(#000000,#111111,#000000);
            /* Safari 5.1, iOS 5.0-6.1, Chrome 10-25, Android 4.0-4.3 */
            background-image: -webkit-linear-gradient(#000000,#111111,#000000);
            /* Firefox 3.6 - 15 */
            background-image: -moz-linear-gradient(#000000,#333333,#000000);
            /* Opera 11.1 - 12 */
            background-image: -o-linear-gradient(#000000,#333333,#000000);
            /* Opera 15+, Chrome 25+, IE 10+, Firefox 16+, Safari 6.1+, iOS 7+, Android 4.4+ */
            background-image: linear-gradient(#000000,#333333,#000000);
		}
        p {
            margin: 0;
            padding: 0;
        }

        .left,
        .right {
            position: absolute;
            color: #fff;

        }

        .left {
			z-index:100;
            top: 0;
            left: 1em;
            text-align: left;
        }
		
		.leftM {
			position: absolute;
            color: #fff;
            top: 50%;
            left: 1em;
            text-align: left;
        }
		.right {
            top: 20%;
            right: 0;
            text-align: right;
        }
		 .top {
            top: 2em;
			width:100%;
            text-align: center;
        }
		 .bottom {
            bottom: 1em;
            right: 1em;
            text-align: left;
        }
		.midR {
            bottom: 50%;
            right: 1em;
            text-align: left;
        }
		 .bottomL {
            bottom: 1em;
            text-align: left;
        }
		.bottomR {
			width:100%;
            bottom: 1em;
            text-align: right;
			color:#aaa;
			z-index:100;
			font-size: 15px;
			font-style: italic;
        }
		.textInfo {
			position: relative;
			color:#fff;
			
			font-size: 11px;
			font-weight: bold;
			text-align: center;
		}
		 .topH {
            top: 0;
			position: relative;
			width : 60%;
			height: 70
			width:100%;
            text-align: center;
			
			background: -webkit-linear-gradient(left, black, #444444, black);
			background: -moz-linear-gradient(left, black, #444444, black);
			background: -ms-linear-gradient(left, black, #444444, black);
			background: -o-linear-gradient(left, black, #444444, black);
        }
		.Header {
			margin-top: 1em;
			color:#ddd;
			font-size: 25px;
			font-weight: bold;
			font-family: "Palatino Linotype", "Book Antiqua", Palatino, serif;
		}
		
		.dg.a { 
			z-index:200 !important;
			overflow: hidden;
			position: absolute !important; 
			top: 13.1em !important; 
			left: 1em !important; 
			width: 300px !important;
		}
		
		 .dg .close-button { display:none;}  		
			
		a { color:skyblue }
    </style>

</head>
<body>

	<div class="bottomR" style = "position: absolute">
		<div id="lblWatermark">Generated by JSA </div>
	</div>
	
	<div class="left">
        <img src="three_logo.png" style="width:150px">
    </div>
	
	<div class="topH" style = "position: absolute" >
		<div class="Header">3D Terrain Generator</div>
	</div>
	
	<div class="bottomL"  border="1" style = "position: absolute;" >
   	    <table style="width:100%">
			<tr>
				<th class="textInfo" style="font-size: 16px;">Column1</th>
				<th class="textInfo" style="font-size: 16px;">Column2</th>
			</tr>
			<tr>
				<td class="textInfo">= 100%</td>
				<td id="Av_eq_100" class="textInfo">0.00%</td>
			</tr>
			<tr>
				<td class="textInfo">&le; 99.9%</td>
				<td id="Av_ge_999" class="textInfo">0.00%</td>
			</tr>
			<tr>
				<td class="textInfo">&le; 99%</td>
				<td id="Av_ge_99" class="textInfo">0.00%</td>
			</tr>
	
		</table> 
		<table style="width:100%">
			<tr>
				<th class="textInfo" style="font-size: 16px;">Column1</th>
				<th class="textInfo" style="font-size: 16px;">Column2</th>
			</tr>
			<tr>
				<td class="textInfo">&le; 5x10<sup>-4</sup></td>
				<td id="Cont_le_5e-4" class="textInfo" >0.00%</td>
			</tr>
		</table> 
	</div>
	
    <div class="right" >
        <table style=" border-spacing: 10px 0px;width:100%;">
			<tr>
				<th colspan= "2" class="textInfo" style="font-size: 16px;">Legend</th>
			</tr>
			<tr>
				<td style="width:15px;height:1px">&nbsp;</td>
				<td >&nbsp;</td>
			</tr>
			<tr>
				<td style="background-color:#00008b;width:15px;height:15px">&nbsp;</td>
				<td class="textInfo">&gt; 3x10<sup>-2</sup></td>
			</tr>
			<tr>
				<td style="background-color:#0040ff;width:15px;height:15px">&nbsp;</td>
				<td class="textInfo">&le; 3x10<sup>-2</sup></td>
			</tr>
			<tr>
				<td style="background-color:#02ffff;width:15px;height:15px">&nbsp;</td>
				<td class="textInfo">&le; 2x10<sup>-2</sup></td>
			</tr>
			<tr>
				<td style="background-color:#02ff00;width:15px;height:15px">&nbsp;</td>
				<td class="textInfo">&le; 1x10<sup>-2</sup></td>
			</tr>
			<tr>
				<td style="background-color:#ffff00;width:15px;height:15px">&nbsp;</td>
				<td class="textInfo">&le; 5x10<sup>-3</sup></td>
			</tr>
			<tr>
				<td style="background-color:#ffa500;width:15px;height:15px">&nbsp;</td>
				<td class="textInfo">&le; 1x10<sup>-3</sup></td>
			</tr>
			<tr>
				<td style="background-color:#ff0000;width:15px;height:15px">&nbsp;</td>
				<td class="textInfo">&le; 5x10<sup>-4</sup></td>
			</tr>
						<tr>
				<td style="background-color:#8b0000;width:15px;height:15px">&nbsp;</td>
				<td class="textInfo">&le; 1x10<sup>-4</sup></td>
			</tr>
			<tr>
				<td style="width:15px;height:15px">&nbsp;</td>
				<td >&nbsp;</td>
			</tr>
			<tr>
				<td style="background-color:#c0c0c0;width:15px;height:15px">&nbsp;</td>
				<td class="textInfo">No Data</td>
			</tr>
			<tr>
				<td style="width:15px;height:5px">&nbsp;</td>
				<td >&nbsp;</td>
			</tr>
		</table> 
    </div>
  
    <script>

        if (!Detector.webgl) {
            Detector.addGetWebGLMessage();
        }

		var Services = ["Type1","Type2"];
		var Suffix = "map3d_";
		
		var gui, parameters;
		var currentScale;
		var meshPlane, showAvPlane, slrPlane;
		var animateStop;
		var geometry, geometry2, dot, showCut;
        var container;
				
		var lastMapDate, currentHour;		 
				 
		var raycaster = new THREE.Raycaster();
		var vector = new THREE.Vector3();
		var dir = new THREE.Vector3();
		var mtlLoader = new THREE.MTLLoader();
		var texloader = new THREE.TextureLoader();
		
		var targetList = [];
		var models = [];
		var initialOrigin;
        var camera, controls, scene, renderer;
        var lighting, ambient, keyLight, fillLight, backLight, hemiLight;
		
		var currentMaterial, material1, material2, meshAv,   wireframe, switchedmaterial;

		var angle = 0;
		var radius = 5; 
		
        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;
        
		init();
		initGUI();
        animate();
		Update();

		function initGUI(){
			gui = new dat.GUI();
				
			parameters = 
			{
				service : Services[0],
				lastUpdate : "03/11/2016 09:59:59",
				AvInfo : "0.0",
				ContInfo : "0.0",
				LatInfo : "0.0",
				LongInfo : "0.0",
				material: false,
				wireframe: true,
				avPlane: false,
				cutPlane: false,
				opacity: 100,
				zoom: 100,				
				scale: 100,
				sliderAv: 50.00
			};
			
			//Add 2 folders
			var infoFolder = gui.addFolder('Information');
			
			var service = infoFolder.add(parameters, 'service',Services).name('Service').listen();		
			service.onChange(function(value) 
			{   
				loadModels(value);
				loadData(value);
			});
							
			var LastUpdate = infoFolder.add(parameters, 'lastUpdate').name('LastUpdate').listen();		
			LastUpdate.domElement.style.pointerEvents = "none";
			//AvInfo.domElement.style.opacity = .5;		
			
			var AvInfo = infoFolder.add(parameters, 'AvInfo').name('Availability').listen();		
			AvInfo.domElement.style.pointerEvents = "none";
			//AvInfo.domElement.style.opacity = .5;		

			var ContInfo = infoFolder.add(parameters, 'ContInfo').name('Continuity').listen();		
			ContInfo.domElement.style.pointerEvents = "none";
			//ContInfo.domElement.style.opacity = .5;		

			var LatInfo = infoFolder.add(parameters, 'LatInfo').name('Latitude').listen();			
			LatInfo.domElement.style.pointerEvents = "none";
			//LatInfo.domElement.style.opacity = .5;		

			var LongInfo = infoFolder.add(parameters, 'LongInfo').name('Longitude').listen();		
			LongInfo.domElement.style.pointerEvents = "none";
			//LongInfo.domElement.style.opacity = .5;				
			
			var optFolder = gui.addFolder('Options');
			
			var chkMaterial = optFolder.add( parameters, 'material' ).name('Material').listen();
			chkMaterial.onChange(function(value) 
			{   
				SwitchMaterial(value);
			});
			
			var chkWireframe = optFolder.add( parameters, 'wireframe' ).name('Wireframe').listen();
			chkWireframe.onChange(function(value) 
			{   
				SwitchWireframe(value);
			});
			
			var cutPlane = optFolder.add( parameters, 'cutPlane' ).name('Cut Plane').listen();
			cutPlane.onChange(function(value)
			{   
				showCut = !showCut;
			});
			
			var slrZoom = optFolder.add( parameters, 'zoom' ).min(0).max(200).step(1).name('Zoom').listen();
			slrZoom.onChange(function(value)
			{   
				camera.zoom = value / 100
				camera.updateProjectionMatrix();
			});
			
			var slrOpacity = optFolder.add( parameters, 'opacity' ).min(0).max(100).step(1).name('Opacity').listen();
			slrOpacity.onChange(function(value)
			{   
				material1.opacity = value/100;
				material2.opacity = value/100;
			});
			
			var slrScale = optFolder.add( parameters, 'scale' ).min(0).max(200).step(1).name('Scale').listen();
			slrScale.onChange(function(value)
			{   
				meshAv.scale.set( 1, value / 100, 1 );
				currentScale =  value / 100;
				ChangeAvPlane(parameters.sliderAv);
			});
			
			var chkAvPlane = optFolder.add( parameters, 'avPlane' ).name('Availability Plane').listen();
			chkAvPlane.onChange(function(value) 
			{   
				ShowPlane(value);
			});
		
			slrPlane = optFolder.add( parameters, 'sliderAv' ).min(0).max(100).step(0.1).name('Coverage (%)').listen();
			slrPlane.onChange(function(value)
			{   
				ChangeAvPlane(value);
			});
			//gui.remove(item);
			slrPlane.domElement.style.pointerEvents = "none";
			slrPlane.domElement.style.opacity = .5;
		
			//dat.GUI.toggleHide();
			gui.open();
			infoFolder.open();
		}
				
		function loadModels(service) {
	
			// Remove object from scene if any
			for (let object of models) {
				 scene.remove(object);
			}
			
			//Initialize target and models
			targetList = [];
			models = [];
	
			/* Model */
            mtlLoader.setBaseUrl('./');
            mtlLoader.setPath('./');
			
			//Load Availability Model	
            mtlLoader.load(Suffix + 'av' + service +  '.mtl', function (materials) {
                materials.preload();

                materials.materials.texture.map.magFilter = THREE.NearestFilter;
                materials.materials.texture.map.minFilter = THREE.LinearFilter;
				
				material1 = materials.materials.texture;
				material2 = materials.materials.texture2;
		
				material1.needsUpdate = true;
				material2.needsUpdate = true;
				
				material1.transparent = true
				material2.transparent = true
				
				currentMaterial = material1;
				currentMaterial.wireframe = wireframe;
						
				//http://stackoverflow.com/questions/26874529/import-zip-files		
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('./');
                objLoader.load(Suffix + 'av' + service +  '.obj.zip', function (object) {
					object.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh ) {
							meshAv = child;
							geometry = new THREE.Geometry().fromBufferGeometry(meshAv.geometry);
						
							meshAv.dynamic = true;
							SwitchWireframe(true)
						}
					} );
	                models.push(object);
					targetList.push(object);
					 scene.add(object);
	            });

            });

			// Load Continuity Model
			mtlLoader.load(Suffix + 'cont' + service +  '.mtl', function (materials) {
                materials.preload();
                materials.materials.texture.map.magFilter = THREE.NearestFilter;
                materials.materials.texture.map.minFilter = THREE.LinearFilter;
						
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('./');
                objLoader.load(Suffix + 'cont' + service +  '.obj.zip', function (object) {
				object.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh ) {
							//meshCont = child;
							geometry2 = new THREE.Geometry().fromBufferGeometry(child.geometry);
						}

					} );
                    models.push(object);
					 scene.add(object);
                });

            });
			
		}
		
        function init() {
		
			bsDiv = document.getElementById("box-shadow-div");
			AvInfo = document.getElementById('AvInfo');
			ContInfo = document.getElementById('ContInfo');
			CoordInfo = document.getElementById('CoordInfo');
            container = document.createElement('div');
            document.body.appendChild(container);

			//var helper = new THREE.CameraHelper( light.shadow.camera );
			//scene.add( helper );
			showCut = false;
			animateStop = false;
			currentScale = 1;
	
            /* Scene */

            scene = new THREE.Scene();
            lighting = true;

			/* Camera */

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 3.3;
			camera.position.y = 1.5;
			camera.position.x = 1.5;
			
			var origin = new THREE.Vector3();
			origin = scene.position;
			origin.x = 0; 
			origin.z = 0; 
			origin.y = -0.5; // Set the camera to see higher
			initialOrigin = origin;
			camera.lookAt(origin);
			
            ambient = new THREE.AmbientLight(0xffffff, 14.0);
			ambient.castShadow = true;
            scene.add(ambient);

			hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.9 );
			hemiLight.color.setHSL( 1, 1,1 );
			hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			hemiLight.position.set( 0, 500, 0 );
			
            keyLight = new THREE.DirectionalLight(new THREE.Color('hsl(30, 100%, 75%)'), 1.0);
            keyLight.position.set(-100, 0, 200);
			keyLight.castShadow = true;
			
            fillLight = new THREE.DirectionalLight(new THREE.Color('hsl(240, 100%, 75%)'), 0.45);
            fillLight.position.set(100, 0, 200);
			fillLight.castShadow = true;

            backLight = new THREE.DirectionalLight(0xffffff, 1.0);
            backLight.position.set(100, 0, -100).normalize();
			backLight.castShadow = true;
			
			if (lighting) {
				 ambient.intensity = 0.25;
				 scene.add(hemiLight );
				 scene.add(keyLight);
				 scene.add(fillLight);
				 scene.add(backLight);
			}
		
			// Shadow Plane			
			var img = new THREE.MeshBasicMaterial({	map:texloader.load(Suffix + "shadow.png"),opacity:0.3,transparent:true });
			//img.map.needsUpdate = true;

			var shadowPlane = new THREE.Mesh(new THREE.PlaneGeometry(6, 6),img);
			shadowPlane.overdraw = true;
			shadowPlane.rotateX(-1.57);
			shadowPlane.position.y -= 0.01; //Avoid clipping with the Continuity map
			scene.add(shadowPlane);

			// Mesh plane
			img = new THREE.MeshBasicMaterial({	map:texloader.load(Suffix + "texture.png"),opacity:0.3,transparent:true });
			//img.map.needsUpdate = true;
	
			meshPlane = new THREE.Mesh(new THREE.PlaneGeometry(4, 4),img);
			meshPlane.overdraw = true;
			meshPlane.rotateX(-1.57);
			meshPlane.position.y += 0.5;
	
			//Add Atmospheric Fog to the scene			
			scene.fog = new THREE.FogExp2( 0x000022, 0.05025 );

            /* Renderer */
            renderer = new THREE.WebGLRenderer( { alpha: true, antialias: false } );
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            //renderer.setClearColor(new THREE.Color("hsl(0, 0%, 10%)"));

            container.appendChild(renderer.domElement);

            /* Controls */

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.enableZoom = false;
			controls.enablePan = false;
			
			// How far you can orbit vertically, upper and lower limits.
			controls.maxPolarAngle = Math.PI/2; 
		
            /* Events */
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', onKeyboardEvent, false);
			
			// when the mouse moves, call the given function
			window.addEventListener( 'mousemove', onMouseMove, false );
			window.addEventListener( 'mousedown', onMousedown, false );

			//setInterval('Update()',300000);
			setInterval('Update()',15000);
        }
		 
		 function onMousedown( event ) {
			animateStop = true;
		 }
		
		 function onMouseMove( event ) {
			event.preventDefault();
				if ( camera instanceof THREE.OrthographicCamera ) {
				vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, - 1 ); // z = - 1 important!
				vector.unproject( camera );
				dir.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
				raycaster.set( vector, dir );
			} else if ( camera instanceof THREE.PerspectiveCamera ) {
				vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 ); // z = 0.5 important!
				vector.unproject( camera );
				raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
			}

			var intersects = raycaster.intersectObjects( targetList, true );
	
		   if (intersects.length > 0) {
				var index = intersects[0].faceIndex;
				var face = intersects[0].face;
				
				var vertices = geometry.vertices;
				var v1 = vertices[ face.a ];
				var v2 = vertices[ face.b ];
				var v3 = vertices[ face.c ];

				// calculate the centroid
				var position = new THREE.Vector3();
				position.x = ( v1.x + v2.x + v3.x ) / 3;
				position.y = ( v1.y + v2.y + v3.y ) / 3;
				position.z = ( v1.z + v2.z + v3.z ) / 3;
				
				position.y *= currentScale;
						
				// http://stackoverflow.com/questions/26887664/three-js-raycasting-intercepting-particles-with-attenuated-sizes
				scene.remove(dot);
				var dotGeometry = new THREE.Geometry();
				dotGeometry.vertices.push(position);
								
				var pSize = 9;
				if (showCut){
					pSize = 16;
				}
				
				var dotMaterial = new THREE.PointsMaterial( { color: 0xFF0000, size: pSize, sizeAttenuation: showCut} );
				if (showCut){
					dotMaterial.opacity = 0.5;
					dotMaterial.transparent = true;
				}
			
				dot = new THREE.Points( dotGeometry, dotMaterial );
				//dot.rotation.z += 90; 
				scene.add( dot );
				
               //Get the average for the continuity at that face
				var vertexColors2 = geometry2.colors;
				var vc1Cont = vertexColors2[face.a];
				var vc2Cont = vertexColors2[face.b];
				var vc3Cont = vertexColors2[face.c];
						 
				 // calculate the centroid
				var positionCont = new THREE.Vector3();
				positionCont.x = (vc1Cont.r + vc2Cont.r + vc3Cont.r) / 3;
				positionCont.y = (vc1Cont.g + vc2Cont.g + vc3Cont.g) / 3;
				positionCont.z = (vc1Cont.b + vc2Cont.b + vc3Cont.b) / 3;
				
		       //Get the Availability a that point
				var vertexColors = geometry.colors;
				var vc1 = vertexColors[ face.a ];
				var vc2 = vertexColors[ face.b ];
				var vc3 = vertexColors[ face.c ];
							 
				 // calculate the centroid
				var positionAv = new THREE.Vector3();
				positionAv.x = (vc1.r + vc2.r + vc3.r) / 3;
				positionAv.y = (vc1.g + vc2.g + vc3.g) / 3;
				positionAv.z = (vc1.b + vc2.b + vc3.b) / 3;
				
				//color.style.background = 0xdddddd;
				parameters.AvInfo = positionAv.z.toFixed(2) + "%";
				parameters.ContInfo = positionCont.z.toExponential(3);
				parameters.LatInfo = positionAv.x.toFixed(5);
				parameters.LongInfo = positionAv.y.toFixed(5);
			}
			else {
				scene.remove(dot);
			
			}
		}
		
        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyboardEvent(e) {
			switch(e.code) {
				case 'KeyL':
					lighting = !lighting;
					if (lighting) {
						ambient.intensity = 0.25;
						scene.add(keyLight);
						scene.add(fillLight);
						scene.add(backLight);
						scene.add( hemiLight );
					} else {
						ambient.intensity = 1.0;
						scene.remove(keyLight);
						scene.remove(fillLight);
						scene.remove(backLight);
						scene.remove( hemiLight );
					}
					break;
				case 'KeyW':
					wireframe = !wireframe;
					currentMaterial.wireframe = wireframe;
					break;
				case 'KeyM':
					switchedmaterial = !switchedmaterial;
					
					if (switchedmaterial){
						currentMaterial = material2;
					}
					else {
						currentMaterial = material1;
					}
					meshAv.material = currentMaterial;
					currentMaterial.wireframe = wireframe;
					break;
				case 'KeyP':
					showCut = !showCut;
					break;
				default:
			} 
        }
			
		function SwitchWireframe(checked) {
			currentMaterial.wireframe = parameters.wireframe;
		}
		
		 function ChangeAvPlane(newVal){
			var palette = [0,70, 80, 90, 95, 98, 99, 99.9,100];
			var levels = [0,30,	40,	50,	60 ,70, 80,	90,	100];
			
			newVal = newVal
			var value = 0;
			//Get the current value from the new Value
			for (i = 0; i < palette.length - 1; i++) {
				if (newVal >= palette[i] && newVal <= palette[i+1] ) {
					//This means the value is inside these two values
					var percent =  (newVal - palette[i]) / (palette[i+1] - palette[i]);
					value = ((levels[i+1] - levels[i]) * percent) + levels[i];
					break;
				}
			}
			//console.log(value);
			meshPlane.position.y = (value / 100) * currentScale;
		}
		 
		
		function ShowPlane(checked) {
			parameters.avPlane = checked;
			if (parameters.avPlane) {
				scene.add(meshPlane);
				slrPlane.domElement.style.pointerEvents = "inherit"
				slrPlane.domElement.style.opacity = 1;
				
			} else {
				scene.remove(meshPlane);
				slrPlane.domElement.style.pointerEvents = "none"
				slrPlane.domElement.style.opacity = .5;
			}
		}
		
		function SwitchMaterial(checked) {
			parameters.material = checked;
					
			if (parameters.material){
				currentMaterial = material2;
			}
			else {
				currentMaterial = material1;
			}
			meshAv.material = currentMaterial;
			currentMaterial.wireframe = parameters.wireframe;
		}
		
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
	
			if (!animateStop) {
				camera.position.x = radius * Math.cos( angle );  
				camera.position.z = radius * Math.sin( angle );
				angle += 0.005;
			}
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }
		
		function loadData(value) {
			var RandomNumber = new Date().getTime();
			// Load the XML and check if new map has been uploaded
			downloadUrl(Suffix + "extra.xml?"+RandomNumber, function(data) {
				//Load extra info depending on the Service
				var XMLmarkers = data.documentElement.getElementsByTagName("commit");
				for (var i = 0; i < XMLmarkers.length; i++) {
					if (value === XMLmarkers[i].getAttribute("service")) {
						var control = document.getElementById(XMLmarkers[i].getAttribute("type"));
						control.innerHTML = XMLmarkers[i].getAttribute("value");
					}
				}
	    	  
						
			});
		}
		
		function Update() {
			var RandomNumber = new Date().getTime();
			// Load the XML and check if new map has been uploaded
			downloadUrl(Suffix + "extra.xml?"+RandomNumber, function(data) {
				  // Get the XML creation date to check if there is a map available.
				  var date = data.documentElement.getElementsByTagName("map_date")[0].getAttribute("end_time");
				  // Check new date or first one
				  if (date != lastMapDate ) {
					lastMapDate = date;
					currentHour = data.documentElement.getElementsByTagName("map_date")[0].getAttribute("hour");
					parameters.lastUpdate = lastMapDate;

					var lblWaterMark = document.getElementById('lblWatermark');
					var creationDate = data.documentElement.getElementsByTagName("xml_creation")[0].getAttribute("time");
					var creationTool = data.documentElement.getElementsByTagName("xml_creation")[0].getAttribute("tool");
					lblWaterMark.innerHTML = "Generated by JSA at " + creationDate;
					
					//Load Models Models
					loadModels(parameters.service);
					loadData(parameters.service);
					
				  }
						
			});
		}

    </script>

</body>
</html>
